use std::{
    path::{Path, PathBuf},
    str::FromStr,
};

use anyhow::{Context, Result, anyhow, bail};
use clap::Parser;
use rattler::install::Installer;
use rattler_conda_types::{Platform, RepoDataRecord};
use rattler_lock::{CondaPackageData, DEFAULT_ENVIRONMENT_NAME, LockFile};
use url::Url;

const DEFAULT_LOCKFILE_NAME: &str = "conda-lock.yml";

#[derive(Debug, Parser)]
#[command(version, about = "Install a conda environment from a rattler lockfile", long_about = None)]
struct Cli {
    /// Directory containing the lockfile generated by `conda-dist`
    #[arg(value_name = "ENV_DIR")]
    environment_dir: PathBuf,

    /// Target prefix where the environment should be installed
    #[arg(value_name = "PREFIX")]
    prefix: PathBuf,

    /// Name of the environment within the lockfile (defaults to the only environment or `default`)
    #[arg(long, value_name = "NAME")]
    environment: Option<String>,

    /// Override the platform to install for (defaults to current platform)
    #[arg(long, value_name = "PLATFORM")]
    platform: Option<String>,
}

#[tokio::main]
async fn main() -> Result<()> {
    let cli = Cli::parse();
    execute(cli).await
}

async fn execute(cli: Cli) -> Result<()> {
    let channel_dir = cli.environment_dir.canonicalize().with_context(|| {
        format!(
            "failed to resolve environment directory {}",
            cli.environment_dir.display()
        )
    })?;

    let lockfile_path = locate_lockfile(&channel_dir)?;
    let lockfile = LockFile::from_path(&lockfile_path)
        .with_context(|| format!("failed to read lockfile at {}", lockfile_path.display()))?;

    let (environment_name, environment) =
        resolve_environment(&lockfile, cli.environment.as_deref())?;

    let target_platform = if let Some(raw) = cli.platform.as_deref() {
        Platform::from_str(raw).with_context(|| format!("failed to parse platform '{raw}'"))?
    } else {
        Platform::current()
    };

    let records = collect_records(environment, target_platform, &channel_dir)?;

    if records.is_empty() {
        bail!(
            "environment '{}' does not contain any packages for platform {}",
            environment_name,
            target_platform.as_str()
        );
    }

    let record_count = records.len();
    let installer = Installer::new().with_target_platform(target_platform);
    let result = installer
        .install(&cli.prefix, records)
        .await
        .context("failed to install environment")?;

    let installed = result.transaction.packages_to_install();
    let removed = result.transaction.packages_to_uninstall();

    println!(
        "installed environment '{}' into {} ({} installs, {} removals)",
        environment_name,
        cli.prefix.display(),
        installed,
        removed
    );
    println!(
        "resolved {} packages for {}",
        record_count,
        target_platform.as_str()
    );

    Ok(())
}

fn locate_lockfile(channel_dir: &Path) -> Result<PathBuf> {
    let candidate = channel_dir.join(DEFAULT_LOCKFILE_NAME);
    if candidate.exists() {
        return Ok(candidate.canonicalize().with_context(|| {
            format!("failed to resolve lockfile path {}", candidate.display())
        })?);
    }

    bail!(
        "no lockfile found; expected {} or specify --lockfile",
        candidate.display()
    );
}

fn resolve_environment<'lock>(
    lockfile: &'lock LockFile,
    requested: Option<&str>,
) -> Result<(String, rattler_lock::Environment<'lock>)> {
    if let Some(name) = requested {
        let environment = lockfile
            .environment(name)
            .with_context(|| format!("environment '{name}' not found in lockfile"))?;
        return Ok((name.to_string(), environment));
    }

    if let Some(environment) = lockfile.default_environment() {
        return Ok((DEFAULT_ENVIRONMENT_NAME.to_string(), environment));
    }

    let environments: Vec<_> = lockfile.environments().collect();
    match environments.as_slice() {
        [] => bail!("lockfile does not contain any environments"),
        [(name, environment)] => Ok(((*name).to_string(), *environment)),
        _ => bail!("lockfile contains multiple environments; pass --environment to select one"),
    }
}

fn collect_records(
    environment: rattler_lock::Environment<'_>,
    target_platform: Platform,
    channel_dir: &Path,
) -> Result<Vec<RepoDataRecord>> {
    let mut records = Vec::new();
    let mut has_target_platform = false;

    for (platform, packages) in environment.conda_packages_by_platform() {
        if platform == target_platform {
            has_target_platform = true;
        }

        if platform != target_platform && platform != Platform::NoArch {
            continue;
        }

        for package in packages {
            match package {
                CondaPackageData::Binary(data) => {
                    let package_path = channel_dir
                        .join(&data.package_record.subdir)
                        .join(&data.file_name);
                    if !package_path.exists() {
                        bail!(
                            "missing package file {} for '{}'",
                            package_path.display(),
                            data.package_record.name.as_source()
                        );
                    }

                    let url = Url::from_file_path(&package_path).map_err(|_| {
                        anyhow!("failed to create file url for {}", package_path.display())
                    })?;

                    let record = RepoDataRecord {
                        package_record: data.package_record.clone(),
                        file_name: data.file_name.clone(),
                        url,
                        channel: Some("local".to_string()),
                    };
                    records.push(record);
                }
                CondaPackageData::Source(data) => {
                    bail!(
                        "cannot install source package '{}' from lockfile",
                        data.package_record.name.as_source()
                    );
                }
            }
        }
    }

    if !has_target_platform {
        bail!(
            "environment does not contain packages for platform {}",
            target_platform.as_str()
        );
    }

    Ok(records)
}
